package com.hackerrank.practice.dictionaries.triplets;

import java.util.Map;
import java.util.List;
import java.util.HashMap;

public class Solution3 extends AbstractSolution {

    public class Pair {

        public long v;
        int howMany;

        public Pair(long v, int howMany) {
            this.v = v;
            this.howMany = howMany;
        }

    }

    @Override
    public boolean accept(String testCase) {
        return true;
    }
    // Complete the countTriplets function below.

    @Override
    protected long countTriplets(List<Long> arr, long r) {
        int n = arr.size();
        if (n < 3) {
            return 0;
        }

        long triplets = 0;

        if (r == 1) {

            // if r == 1, we have v*r == v*r*r and the approach discussed below will not work.
            // in this case we simply have to count the occurrences of the same numbers and then
            // compute the number of triplets as the possible number of combinations of 3 items
            // out of a set composing the total number of occurrences.
            //
            // triplets(k) = f(k)!/((f(k)-r)!*r!) |r=3, f(k)>2
            // triplets(k) = f(k)*(f(k)-1)*(f(k)-2)*(f(k)-3)! / (f(k)-3)!*3!
            //             = f(k)*(f(k)-1)*(f(k)-2)/6 
            //
            //
            //
            Map<Long,Long> histogram = new HashMap<>();
            for(Long l : arr) {
                Long frequency = histogram.get(l);
                histogram.put(l, frequency == null ? 1 : frequency + 1);
            }  
            for(Long frequency : histogram.values()) {
                 // if the value is present for sure it is > 0
                 // then we don't need to check whether it is > 2 because the formula will nullify the value for 1 and 2
                 // we put them at the front of the multiplication so that we are a bit quicker. We expect that the single 
                 // occurrences are more frequent than doubles.
                 triplets += (frequency-1)*(frequency-2)*(frequency)/6;
            }

        } else {

            Map<Long, Pair> pairs = new HashMap<>();
            Map<Long, Integer> histogram = new HashMap<>();
            for(int i=n; i>0; i--) {
                long v = arr.get(i-1);
                // step 1: we compute the first multiplier
                //         this is the only one we need.
                long vr = v*r;
                

                // step 2: we check in the list of pair
                //         if we find it then we have a
                //         set of triplets.
                Pair pair = pairs.get(vr);
                if (pair != null) {
                    
                    // the triplets generated by this instance
                    // are computed by all the followers <vr, vrr>
                    // this value is computed by summing the howMany
                    // of each pair.
                    triplets += pair.howMany;

                }
                
                // System.out.println("i: " + (i-1) + ", v: " + v + ", vr: " + vr + ", pairs: " + vrHowMany);
                

                // step 2: we check whether this entry causes a pair.
                //         if we found triplets that is for sure, if
                //         we have not found triplets, it may still
                //         cause a pair and we need to check whether
                //         vr is in the histogram.

                Integer zombie = histogram.get(vr);
                int vrHowMany = zombie == null ? 0 : zombie;


                if (vrHowMany > 0) {
                    // ok this means that there are some vr in the array
                    // that we scanned down to now. We need to enter a 
                    // pair that matches v with vr, for the current value.

                    pair = pairs.get(v);
                    if (pair == null) {
                        pair = new Pair(v, 0);
                    }
                    pair.howMany += vrHowMany;
                    pairs.put(v, pair);
                }

                // step 3: we update the histogram because we have seen the
                //         element.
                //
                Integer vHowMany = histogram.get(v);
                histogram.put(v, vHowMany == null ? 1 : vHowMany + 1);
            }
        }

        return triplets;        

    }
}